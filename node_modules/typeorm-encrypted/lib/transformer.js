"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var typeorm_1 = require("typeorm");
var crypto_1 = require("./crypto");
var EncryptionTransformer = /** @class */ (function () {
    function EncryptionTransformer(options) {
        this.options = options;
    }
    EncryptionTransformer.prototype.from = function (value) {
        if (!value) {
            return;
        }
        return crypto_1.decryptData(Buffer.from(value, 'base64'), this.options).toString('utf8');
    };
    EncryptionTransformer.prototype.to = function (value) {
        var _this = this;
        var _a;
        if ((value !== null && value !== void 0 ? value : null) === null) {
            return;
        }
        if (typeof value === 'string') {
            return crypto_1.encryptData(Buffer.from(value, 'utf8'), this.options).toString('base64');
        }
        if (!value) {
            return;
        }
        // Support FindOperator.
        // Just support "Equal", "In", "Not", and "IsNull".
        // Other operators aren't work correctly, because values are encrypted on the db.
        if (value.type === "in") {
            return typeorm_1.In(value.value.map(function (s) {
                return crypto_1.encryptData(Buffer.from(s, 'utf-8'), _this.options).toString('base64');
            }));
        }
        else if (value.type === 'equal') {
            return typeorm_1.Equal(crypto_1.encryptData(Buffer.from(value.value, 'utf-8'), this.options).toString('base64'));
        }
        else if (value.type === 'not') {
            return typeorm_1.Not(this.to((_a = value.child) !== null && _a !== void 0 ? _a : value.value));
        }
        else if (value.type === 'isNull') {
            return value;
        }
        else {
            throw new Error('Only "Equal","In", "Not", and "IsNull" are supported for FindOperator');
        }
    };
    return EncryptionTransformer;
}());
exports.EncryptionTransformer = EncryptionTransformer;
var JSONEncryptionTransformer = /** @class */ (function () {
    function JSONEncryptionTransformer(options) {
        this.options = options;
    }
    JSONEncryptionTransformer.prototype.from = function (value) {
        if (!value || !value.encrypted) {
            return;
        }
        var decrypted = crypto_1.decryptData(Buffer.from(value.encrypted, 'base64'), this.options).toString('utf8');
        return JSON.parse(decrypted);
    };
    JSONEncryptionTransformer.prototype.to = function (value) {
        if ((value !== null && value !== void 0 ? value : null) === null) {
            return;
        }
        if (typeof value === 'object' && !(value === null || value === void 0 ? void 0 : value.type)) {
            var encrypted = crypto_1.encryptData(Buffer.from(JSON.stringify(value), 'utf8'), this.options).toString('base64');
            return { encrypted: encrypted };
        }
        if (!value) {
            return;
        }
        // FindOperators are not supported.
        throw new Error('Filter operators are not supported for JSON encrypted fields');
    };
    return JSONEncryptionTransformer;
}());
exports.JSONEncryptionTransformer = JSONEncryptionTransformer;
//# sourceMappingURL=transformer.js.map