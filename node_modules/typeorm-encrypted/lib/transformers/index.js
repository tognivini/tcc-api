"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var typeorm_1 = require("typeorm");
var crypto_1 = require("crypto");
/**
 * Encrypt fields on entity.
 */
function encrypt(entity) {
    if (!entity) {
        return entity;
    }
    for (var _i = 0, _a = typeorm_1.getMetadataArgsStorage().columns; _i < _a.length; _i++) {
        var columnMetadata = _a[_i];
        var propertyName = columnMetadata.propertyName, mode = columnMetadata.mode, target = columnMetadata.target;
        var options = columnMetadata.options;
        var encrypt_1 = options.encrypt;
        if (encrypt_1 && mode === "regular" && (encrypt_1.looseMatching || entity.constructor === target)) {
            if (entity[propertyName]) {
                entity[propertyName] = encryptData(Buffer.from(entity[propertyName], "utf8"), encrypt_1).toString("base64");
            }
        }
    }
    return entity;
}
exports.encrypt = encrypt;
/**
 * Encrypt data.
 */
function encryptData(data, options) {
    var iv = options.iv ? Buffer.from(options.iv, "hex") : crypto_1.randomBytes(options.ivLength);
    var cipher = crypto_1.createCipheriv(options.algorithm, Buffer.from(options.key, "hex"), iv);
    var start = cipher.update(data);
    var final = cipher.final();
    return Buffer.concat([iv, start, final]);
}
exports.encryptData = encryptData;
/**
 * Decrypt fields on entity.
 */
function decrypt(entity) {
    if (!entity) {
        return entity;
    }
    for (var _i = 0, _a = typeorm_1.getMetadataArgsStorage().columns; _i < _a.length; _i++) {
        var columnMetadata = _a[_i];
        var propertyName = columnMetadata.propertyName, mode = columnMetadata.mode, target = columnMetadata.target;
        var options = columnMetadata.options;
        var encrypt_2 = options.encrypt;
        if (encrypt_2 && mode === "regular" && (encrypt_2.looseMatching || entity.constructor === target)) {
            if (entity[propertyName]) {
                entity[propertyName] = decryptData(Buffer.from(entity[propertyName], "base64"), encrypt_2).toString("utf8");
            }
        }
    }
    return entity;
}
exports.decrypt = decrypt;
/**
 * Decrypt data.
 */
function decryptData(data, options) {
    var iv = data.slice(0, options.ivLength);
    var decipher = crypto_1.createDecipheriv(options.algorithm, Buffer.from(options.key, "hex"), iv);
    var start = decipher.update(data.slice(options.ivLength));
    var final = decipher.final();
    return Buffer.concat([start, final]);
}
exports.decryptData = decryptData;
//# sourceMappingURL=index.js.map