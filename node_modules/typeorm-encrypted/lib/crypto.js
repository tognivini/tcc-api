"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var crypto_1 = require("crypto");
var DEFAULT_AUTH_TAG_LENGTH = 16;
function hasAuthTag(algorithm) {
    return algorithm.endsWith('-gcm') || algorithm.endsWith('-ccm') || algorithm.endsWith('-ocb');
}
/**
 * Encrypt data.
 */
function encryptData(data, options) {
    var algorithm = options.algorithm, authTagLength = options.authTagLength, ivLength = options.ivLength, key = options.key;
    var iv = options.iv
        ? Buffer.from(options.iv, 'hex')
        : crypto_1.randomBytes(ivLength);
    var cipherOptions = { authTagLength: authTagLength !== null && authTagLength !== void 0 ? authTagLength : DEFAULT_AUTH_TAG_LENGTH };
    var cipher = crypto_1.createCipheriv(algorithm, Buffer.from(key, 'hex'), iv, cipherOptions);
    var start = cipher.update(data);
    var final = cipher.final();
    if (hasAuthTag(options.algorithm)) {
        return Buffer.concat([iv, cipher.getAuthTag(), start, final]);
    }
    else {
        return Buffer.concat([iv, start, final]);
    }
}
exports.encryptData = encryptData;
/**
 * Decrypt data.
 */
function decryptData(data, options) {
    var _a;
    var algorithm = options.algorithm, ivLength = options.ivLength, key = options.key;
    var authTagLength = (_a = options.authTagLength) !== null && _a !== void 0 ? _a : DEFAULT_AUTH_TAG_LENGTH;
    var iv = data.slice(0, ivLength);
    var decipher = crypto_1.createDecipheriv(algorithm, Buffer.from(key, 'hex'), iv);
    var dataToUse = data.slice(options.ivLength);
    if (hasAuthTag(options.algorithm)) {
        // Add ts-ignore due to build error TS2339: Property 'setAuthTag' does not exist on type 'Decipher'.
        // @ts-ignore
        decipher.setAuthTag(dataToUse.slice(0, authTagLength));
        dataToUse = dataToUse.slice(authTagLength);
    }
    var start = decipher.update(dataToUse);
    var final = decipher.final();
    return Buffer.concat([start, final]);
}
exports.decryptData = decryptData;
//# sourceMappingURL=crypto.js.map